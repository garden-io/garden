/*
 * Copyright (C) 2018-2025 Garden Technologies, Inc. <info@garden.io>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

import { diff } from "json-diff"
import { safeDumpYaml } from "./serialization.js"
import { styles } from "../logger/styles.js"
import { cloneDeep, isPlainObject, omit } from "lodash-es"

export interface YamlDiffOptions {
  /** Whether to use colors in the output (default: true) */
  useColors?: boolean
}

export interface ResourceChange {
  key: string
  operation: "create" | "update" | "delete" | "unchanged"
  diffOutput?: string
}

export interface YamlDiffResult {
  /** Whether there are any differences */
  hasDiff: boolean
  /** The formatted diff string */
  diffOutput: string
  /** Individual resource changes for detailed summary */
  resourceChanges: ResourceChange[]
  /** Summary of changes */
  summary: {
    create: number
    update: number
    delete: number
    unchanged: number
  }
}

/**
 * Fields that are added by Kubernetes server-side and should be ignored in comparisons.
 * These fields are not part of the user's manifest but are added by the API server.
 */
const SERVER_SIDE_METADATA_FIELDS = [
  "uid",
  "resourceVersion",
  "creationTimestamp",
  "generation",
  "selfLink",
  "managedFields",
  "finalizers",
  "ownerReferences",
]

/**
 * Annotation prefixes that should be stripped entirely (all annotations starting with these).
 */
const IGNORED_ANNOTATION_PREFIXES = [
  "garden.io/",
  "kubectl.kubernetes.io/",
  "deployment.kubernetes.io/",
  "control-plane.alpha.kubernetes.io/",
  "kubernetes.io/",
]

/**
 * Service-specific fields that are auto-generated by Kubernetes.
 */
const SERVICE_SERVER_SIDE_SPEC_FIELDS = [
  "clusterIP",
  "clusterIPs",
  "sessionAffinity",
  "externalTrafficPolicy",
  "ipFamilies",
  "ipFamilyPolicy",
  "allocateLoadBalancerNodePorts",
  "internalTrafficPolicy",
]

/**
 * Extracts the last-applied-configuration from a resource if available.
 * This represents what was actually applied, without server-side additions.
 */
export function getLastAppliedConfiguration<T extends object>(resource: T): T | null {
  const res = resource as any
  const lastApplied = res?.metadata?.annotations?.["kubectl.kubernetes.io/last-applied-configuration"]

  if (lastApplied && typeof lastApplied === "string") {
    try {
      return JSON.parse(lastApplied) as T
    } catch {
      return null
    }
  }
  return null
}

/**
 * Strips server-side metadata from a Kubernetes resource for comparison purposes.
 * This ensures we only compare the fields that the user controls.
 *
 * @param resource The resource to strip
 * @param useLastApplied If true and last-applied-configuration is available, use that instead
 */
export function stripServerSideMetadata<T extends object>(resource: T, useLastApplied: boolean = true): T {
  if (!resource || typeof resource !== "object") {
    return resource
  }

  // If we have last-applied-configuration, use that as the basis for comparison
  // since it represents what was actually applied without server-side additions
  if (useLastApplied) {
    const lastApplied = getLastAppliedConfiguration(resource)
    if (lastApplied) {
      // Still strip metadata from the last-applied to normalize
      return stripServerSideMetadataInternal(lastApplied)
    }
  }

  return stripServerSideMetadataInternal(resource)
}

function stripServerSideMetadataInternal<T extends object>(resource: T): T {
  if (!resource || typeof resource !== "object") {
    return resource
  }

  const result = cloneDeep(resource) as any

  // Strip top-level status
  if ("status" in result) {
    delete result.status
  }

  // Strip server-side metadata fields
  if (result.metadata) {
    result.metadata = omit(result.metadata, SERVER_SIDE_METADATA_FIELDS)

    // Strip annotations with ignored prefixes
    if (result.metadata.annotations) {
      const annotationsToRemove: string[] = []
      for (const key of Object.keys(result.metadata.annotations)) {
        for (const prefix of IGNORED_ANNOTATION_PREFIXES) {
          if (key.startsWith(prefix)) {
            annotationsToRemove.push(key)
            break
          }
        }
      }
      for (const key of annotationsToRemove) {
        delete result.metadata.annotations[key]
      }
      // Remove annotations object if empty
      if (Object.keys(result.metadata.annotations).length === 0) {
        delete result.metadata.annotations
      }
    }

    // Strip labels with garden.io prefix
    if (result.metadata.labels) {
      const labelsToRemove: string[] = []
      for (const key of Object.keys(result.metadata.labels)) {
        if (key.startsWith("garden.io/")) {
          labelsToRemove.push(key)
        }
      }
      for (const key of labelsToRemove) {
        delete result.metadata.labels[key]
      }
      if (Object.keys(result.metadata.labels).length === 0) {
        delete result.metadata.labels
      }
    }
  }

  // Strip Service-specific auto-generated fields
  if (result.kind === "Service" && result.spec) {
    result.spec = omit(result.spec, SERVICE_SERVER_SIDE_SPEC_FIELDS)

    // Strip auto-assigned nodePort from ports
    if (result.spec.ports && Array.isArray(result.spec.ports)) {
      result.spec.ports = result.spec.ports.map((port: any) => {
        // Only strip nodePort if it wasn't explicitly set (we can't know for sure,
        // but we strip it to reduce noise - users who explicitly set it will see it in the new manifest)
        const { nodePort: _nodePort, ...rest } = port
        return rest
      })
    }
  }

  // Handle nested pod template spec (for Deployments, StatefulSets, etc.)
  if (result.spec?.template?.metadata) {
    result.spec.template.metadata = omit(result.spec.template.metadata, SERVER_SIDE_METADATA_FIELDS)

    // Strip garden.io annotations/labels from pod template
    if (result.spec.template.metadata.annotations) {
      for (const key of Object.keys(result.spec.template.metadata.annotations)) {
        for (const prefix of IGNORED_ANNOTATION_PREFIXES) {
          if (key.startsWith(prefix)) {
            delete result.spec.template.metadata.annotations[key]
            break
          }
        }
      }
      if (Object.keys(result.spec.template.metadata.annotations).length === 0) {
        delete result.spec.template.metadata.annotations
      }
    }
    if (result.spec.template.metadata.labels) {
      for (const key of Object.keys(result.spec.template.metadata.labels)) {
        if (key.startsWith("garden.io/")) {
          delete result.spec.template.metadata.labels[key]
        }
      }
      if (Object.keys(result.spec.template.metadata.labels).length === 0) {
        delete result.spec.template.metadata.labels
      }
    }
  }

  // Strip Deployment-specific auto-generated fields
  if ((result.kind === "Deployment" || result.kind === "StatefulSet" || result.kind === "DaemonSet") && result.spec) {
    // These are sometimes auto-filled
    if (result.spec.revisionHistoryLimit === 10) {
      delete result.spec.revisionHistoryLimit
    }
    if (result.spec.progressDeadlineSeconds === 600) {
      delete result.spec.progressDeadlineSeconds
    }
    if (result.spec.strategy?.type === "RollingUpdate" && !result.spec.strategy.rollingUpdate) {
      delete result.spec.strategy
    }
  }

  return result
}

/**
 * Recursively processes json-diff output to generate colored YAML-style diff.
 */
function formatJsonDiff(diffObj: any, indent: string = "", useColors: boolean = true): string[] {
  const lines: string[] = []

  if (diffObj === undefined || diffObj === null) {
    return lines
  }

  if (Array.isArray(diffObj)) {
    for (let i = 0; i < diffObj.length; i++) {
      const item = diffObj[i]
      if (Array.isArray(item) && item.length === 2) {
        // This is a change tuple from json-diff: ["-", value] or ["+", value]
        const [op, value] = item
        if (op === "-") {
          const yaml = safeDumpYaml(value, { noRefs: true }).trim()
          for (const line of yaml.split("\n")) {
            const formatted = `${indent}- ${line}`
            lines.push(useColors ? styles.error(formatted) : formatted)
          }
        } else if (op === "+") {
          const yaml = safeDumpYaml(value, { noRefs: true }).trim()
          for (const line of yaml.split("\n")) {
            const formatted = `${indent}+ ${line}`
            lines.push(useColors ? styles.success(formatted) : formatted)
          }
        } else if (op === "~") {
          // Modified item - recurse
          lines.push(...formatJsonDiff(value, indent + "  ", useColors))
        }
      } else if (isPlainObject(item)) {
        // Regular object in array
        lines.push(...formatJsonDiff(item, indent + "  ", useColors))
      }
    }
  } else if (isPlainObject(diffObj)) {
    for (const [key, value] of Object.entries(diffObj)) {
      if (key.endsWith("__deleted")) {
        // Deleted key
        const realKey = key.replace("__deleted", "")
        const yaml = safeDumpYaml({ [realKey]: value }, { noRefs: true }).trim()
        for (const line of yaml.split("\n")) {
          const formatted = `${indent}- ${line}`
          lines.push(useColors ? styles.error(formatted) : formatted)
        }
      } else if (key.endsWith("__added")) {
        // Added key
        const realKey = key.replace("__added", "")
        const yaml = safeDumpYaml({ [realKey]: value }, { noRefs: true }).trim()
        for (const line of yaml.split("\n")) {
          const formatted = `${indent}+ ${line}`
          lines.push(useColors ? styles.success(formatted) : formatted)
        }
      } else if (isPlainObject(value) && "__old" in (value as object) && "__new" in (value as object)) {
        // Modified scalar value
        const typedValue = value as { __old: unknown; __new: unknown }
        const oldFormatted = `${indent}- ${key}: ${JSON.stringify(typedValue.__old)}`
        const newFormatted = `${indent}+ ${key}: ${JSON.stringify(typedValue.__new)}`
        lines.push(useColors ? styles.error(oldFormatted) : oldFormatted)
        lines.push(useColors ? styles.success(newFormatted) : newFormatted)
      } else if (isPlainObject(value) || Array.isArray(value)) {
        // Nested object/array with changes
        const nestedLines = formatJsonDiff(value, indent + "  ", useColors)
        if (nestedLines.length > 0) {
          const keyLine = `${indent}  ${key}:`
          lines.push(useColors ? styles.primary(keyLine) : keyLine)
          lines.push(...nestedLines)
        }
      }
    }
  }

  return lines
}

/**
 * Generates a colored diff between two objects using json-diff for structural comparison.
 *
 * @param oldObj The old/current object (what's deployed)
 * @param newObj The new/desired object (what would be deployed)
 * @param options Diff options
 * @returns Formatted diff result
 */
export function generateYamlDiff(
  oldObj: object | null | undefined,
  newObj: object | null | undefined,
  options: YamlDiffOptions = {}
): { hasDiff: boolean; diffOutput: string } {
  const { useColors = true } = options

  // Handle null/undefined cases
  if (!oldObj && !newObj) {
    return { hasDiff: false, diffOutput: "" }
  }

  // For the old (deployed) object, prefer using last-applied-configuration if available
  // This gives us a cleaner comparison without server-side additions
  const cleanOld = oldObj ? stripServerSideMetadata(oldObj, true) : null

  // For the new object, we just strip server-side metadata (there's no last-applied yet)
  const cleanNew = newObj ? stripServerSideMetadata(newObj, false) : null

  // Use json-diff for structural comparison
  const diffResult = diff(cleanOld, cleanNew)

  if (!diffResult) {
    return { hasDiff: false, diffOutput: "" }
  }

  // Format the diff output
  const lines = formatJsonDiff(diffResult, "", useColors)

  return {
    hasDiff: lines.length > 0,
    diffOutput: lines.join("\n"),
  }
}

/**
 * Formats a resource header for the diff output.
 */
function formatResourceHeader(
  key: string,
  operation: "create" | "update" | "delete" | "unchanged",
  useColors: boolean = true
): string {
  const operationSymbols = {
    create: "+",
    update: "~",
    delete: "-",
    unchanged: "=",
  }

  const operationLabels = {
    create: "CREATE",
    update: "UPDATE",
    delete: "DELETE",
    unchanged: "UNCHANGED",
  }

  const symbol = operationSymbols[operation]
  const label = operationLabels[operation]
  const header = `--- ${symbol} ${label}: ${key} ---`

  if (!useColors) {
    return header
  }

  switch (operation) {
    case "create":
      return styles.success(header)
    case "delete":
      return styles.error(header)
    case "update":
      return styles.warning(header)
    case "unchanged":
      return styles.primary(header)
  }
}

/**
 * Formats all lines of a YAML object as additions.
 */
function formatAddedResource(obj: object, useColors: boolean = true): string {
  const yaml = safeDumpYaml(obj, { noRefs: true })
  const lines = yaml.split("\n").filter((l) => l.trim())
  const formatted = lines.map((line) => `+ ${line}`).join("\n")
  return useColors ? styles.success(formatted) : formatted
}

/**
 * Formats all lines of a YAML object as deletions.
 */
function formatRemovedResource(obj: object, useColors: boolean = true): string {
  const yaml = safeDumpYaml(obj, { noRefs: true })
  const lines = yaml.split("\n").filter((l) => l.trim())
  const formatted = lines.map((line) => `- ${line}`).join("\n")
  return useColors ? styles.error(formatted) : formatted
}

/**
 * Generates a YAML diff for multiple resources.
 * Useful for comparing sets of Kubernetes manifests.
 *
 * @param oldResources Array of old/current resources (what's deployed)
 * @param newResources Array of new/desired resources (what would be deployed)
 * @param getKey Function to get a unique key for each resource
 * @param options Diff options
 */
export function generateMultiResourceYamlDiff<T extends object>(
  oldResources: T[],
  newResources: T[],
  getKey: (resource: T) => string,
  options: YamlDiffOptions = {}
): YamlDiffResult {
  const { useColors = true } = options

  const oldByKey = new Map(oldResources.map((r) => [getKey(r), r]))
  const newByKey = new Map(newResources.map((r) => [getKey(r), r]))

  const allKeys = new Set([...oldByKey.keys(), ...newByKey.keys()])

  const outputs: string[] = []
  const resourceChanges: ResourceChange[] = []

  let createCount = 0
  let updateCount = 0
  let deleteCount = 0
  let unchangedCount = 0

  // Sort keys for consistent output
  const sortedKeys = Array.from(allKeys).sort()

  for (const key of sortedKeys) {
    const oldResource = oldByKey.get(key)
    const newResource = newByKey.get(key)

    if (!oldResource && newResource) {
      // Resource is being created
      createCount++
      const cleanNew = stripServerSideMetadata(newResource)
      outputs.push(formatResourceHeader(key, "create", useColors))
      outputs.push(formatAddedResource(cleanNew, useColors))
      outputs.push("") // Empty line between resources
      resourceChanges.push({ key, operation: "create" })
    } else if (oldResource && !newResource) {
      // Resource is being deleted
      deleteCount++
      const cleanOld = stripServerSideMetadata(oldResource)
      outputs.push(formatResourceHeader(key, "delete", useColors))
      outputs.push(formatRemovedResource(cleanOld, useColors))
      outputs.push("") // Empty line between resources
      resourceChanges.push({ key, operation: "delete" })
    } else if (oldResource && newResource) {
      // Resource may be modified - compare after stripping server-side metadata
      const result = generateYamlDiff(oldResource, newResource, { useColors })

      if (result.hasDiff) {
        updateCount++
        outputs.push(formatResourceHeader(key, "update", useColors))
        outputs.push(result.diffOutput)
        outputs.push("") // Empty line between resources
        resourceChanges.push({ key, operation: "update", diffOutput: result.diffOutput })
      } else {
        unchangedCount++
        resourceChanges.push({ key, operation: "unchanged" })
      }
    }
  }

  const hasDiff = createCount > 0 || updateCount > 0 || deleteCount > 0

  return {
    hasDiff,
    diffOutput: outputs.join("\n").trim(),
    resourceChanges,
    summary: {
      create: createCount,
      update: updateCount,
      delete: deleteCount,
      unchanged: unchangedCount,
    },
  }
}
